Three steps to Compute Engine startup-time bliss: Google Cloud Performance Atlas

## [Three steps to Compute Engine startup-time bliss: Google Cloud Performance Atlas](https://cloudplatform.googleblog.com/2017/07/three-steps-to-Compute-Engine-startup-time-bliss-Google-Cloud-Performance-Atlas.html)

Wednesday, July 26, 2017
 By Colt McAnlis, Developer Advocate

Scaling to millions of requests, with less headaches, is one of the joys of working on [Google Cloud Platform](https://cloud.google.com/) (GCP). With [Compute Engine](https://cloud.google.com/compute/), you can leverage technologies like [Instance Groups](https://cloud.google.com/compute/docs/instance-groups/) and [Load Balancing](https://cloud.google.com/load-balancing/) to make it even easier. However, there comes a point with VM-based applications where the time it takes to boot up your instance can be problematic if you’re also trying to scale to handle a usage spike.

Before startup time causes woes in your application, let’s take a look at three simple steps to find what parts of bootup are taking the most time and how you can shorten your boot time.

### Where does the time go?

One of the most important first steps to clearing up your startup time performance is to [profile the official boot stages](https://medium.com/google-cloud/understanding-and-profiling-gce-cold-boot-time-32c209fe86ab) at a macro level. This gives you a sense of how long Compute Engine is taking to create your instance, vs. how much time your code is taking to run. While the [official documentation](https://cloud.google.com/compute/docs/instances/checking-instance-status) lists the three startup phases as **provisioning**, **staging** and **running**, it’s a little easier to do performance testing on **request**, **provisioning** and **booting**, since we can time each stage externally, right from [Cloud Shell](https://cloud.google.com/shell/docs/).

- **Request** is the time between asking for a VM and getting a response back from the [Create Instance API](https://cloud.google.com/sdk/gcloud/reference/compute/instances/create) acknowledging that you’ve asked for it. We can directly profile this by timing how long it takes GCP to respond to the [insert instance](https://cloud.google.com/compute/docs/reference/latest/instances/insert) REST command.
- **Provisioning** is the time GCE takes to find space for your VM on its architecture; you can find this by polling the [Get Instance API](https://cloud.google.com/compute/docs/reference/latest/instances/get) on a regular basis, and wait for the “status” flag to change from “provisioning” to “running.”
- **Boot time** is when your startup scripts, and other custom code, executes; all the way up to the point when the instance is available. Fellow Cloud Developer Advocate [Terry Ryan](https://twitter.com/tpryan) likes to profile this stage by repeatedly polling the endpoint, and timing the change between receiving 500, 400 and 200 status codes

|     |
| --- |
| [![gce-startup-recap-3.png](../_resources/949a67e03b275a12cf29872b84cd20b3.png)](https://4.bp.blogspot.com/-2oGbmsX0gmY/WXjTIlI9xpI/AAAAAAAAELE/3N0deLLuHsAdL2NjqR8F5SMsrp3VUxqSwCLcBGAs/s1600/gce-startup-recap-3.png) |
| An example graph generated by timing the request, provision and boot stages, measured 183 times |

### Profiling your startup scripts

Barring some unforeseen circumstance, the majority of boot-up time for your instances usually happens during the **boot** phase, when your instance executes its startup scripts. As such, it’s extremely [helpful to profile your boot scripts](https://medium.com/google-cloud/improving-gce-boot-times-with-custom-images-f77921a2c115) in order to see which phases are creating performance bottlenecks.

Timing your startup scripts is a little trickier than it may seem at first glance. Chances are that your code is integrated into a very powerful tooling system (like [Stackdriver Custom Metric API](https://cloud.google.com/monitoring/custom-metrics/), [statsd](https://github.com/etsy/statsd) or [brubeck](https://github.com/github/brubeck)) to help you profile and monitor performance. However applying each one to the startup scripts can create a difficult interaction and boot time overhead, which could skew your profiling results, thus making the testing meaningless.

One neat trick that gets the job done is wrapping each section of your startup script with the [SECONDS command](https://stackoverflow.com/questions/8903239/how-to-calculate-time-difference-in-bash-script) (if you're on a [linux build](https://cloud.google.com/compute/docs/images#os-compute-support)), then append the time elapsed for each stage to a file, and set up a new endpoint to serve that file when requested.

This allows you to poll the endpoint from an external location and get data back without too much heavy lifting or modification to your service. This method will also give you a sense of what stages of your script are taking the most boot time.

|     |
| --- |
| [![gce-startup-recap-2.png](../_resources/c8258b7bd11f4e8ae3c0fc9ca6aba2c3.png)](https://3.bp.blogspot.com/-zJJuve5v8AM/WXjTIkvOU7I/AAAAAAAAELA/u5Ci15YPi4MjDInXjYguB2Dy7a8C7pTRQCEwYBhgL/s1600/gce-startup-recap-2.png) |
| An example graph generated by timing each stage in a linux startup script |

### Moving to custom images

For most developers, most of the time that a startup script runs is bringing down packages and installing applications to allow the service to run properly. That’s because many instances are created with [public images](https://cloud.google.com/compute/docs/images#os-compute-support) — preconfigured combinations of OS and bootloaders. These images are great when you want to get up and running fast, but as you start building production-level systems, you’ll soon realize that the large portion of bootup time is no longer booting the OS, but the user-executed startup sequence that grabs packages and binaries and initializes them.

You can address this by creating [custom images](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images) for your instance. Create a custom image by taking a snapshot of the host disk information (post-boot and install), and store it in a distribution location. Later, when the target instance is booted, the image information is copied right to the hard drive. This is ideal for situations where you've created and modified a root persistent disk to a certain state and would like to save that state to reuse it with new instances. It’s also good when your setup includes installing (and compiling) a number of big libraries, or pieces of software.

|     |
| --- |
| [![gce-startup-recap-1.png](../_resources/af5c6f5950efc021adf2120a78b54b86.png)](https://3.bp.blogspot.com/-5gOhTaRmjmc/WXjTIhbmtUI/AAAAAAAAEK8/qHUAy4gSyMwzaFWqsaBkGI1sQjPWdKLOwCEwYBhgL/s1600/gce-startup-recap-1.png) |
| An example graph generated by timing the startup phases of the instance. Notice that the graph on the right side is in sub-second scale. |

### Every millisecond counts

When you’re trying to scale to millions of requests per second, being serviced by thousands of instances, small change in boot time can make a big difference in costs, response time and most importantly, the perception of performance by your users.

If you’d like to know more about ways to optimize your Google Cloud applications, check out the rest of the [Google Cloud Performance Atlas blog posts](https://medium.com/@duhroach/) and [videos](https://www.youtube.com/watch?list=PLIivdWyY5sqK5zce0-fd1Vam7oPY-s_8X&v=vuVpxOIA8Wc) because when it comes to performance, every millisecond counts.

![Share on Google+](../_resources/c620b1a7b369ad2749d0baf881d4ccbb.png)![Share on Twitter](../_resources/4e2633eb72f2026ba8464540a445a45f.png)![Share on Facebook](../_resources/a4a815e062b3a04ad2cb425115438650.png)

4 comments

[![photo.jpg](../_resources/3a9b670eec7f016e19b9e919f0d0c8e3.jpg)](https://apis.google.com/u/0/wm/1/100180575185522802900)

Add a comment as Marc Cohen

Top comments

## Stream

[![post_facebook_black_24dp.png](../_resources/441cbb7966e7b6b7c013d10a2d98b1b5.png)](https://apis.google.com/u/0/wm/1/106231718867037387503)

### [Gary Darnell](https://apis.google.com/u/0/wm/1/106231718867037387503) shared this via Google+

[2 weeks ago](https://apis.google.com/u/0/wm/1/106231718867037387503/posts/jcz9nwYaPki)  -  Shared publicly

+
0
1
0

[![photo.jpg](../_resources/f95eb0bc593e4488db0fa2c76b1d3fa2.jpg)](https://apis.google.com/u/0/wm/1/117220853931310837595)

### [Elston Technology Services, LLC](https://apis.google.com/u/0/wm/1/117220853931310837595)

[3 weeks ago](https://apis.google.com/u/0/wm/1/+ElstonTechnologyServicesLLCTempe/posts/fRJvgFNe3jt)  -  Shared publicly

Via the wonderful people at Google... Three steps to Compute Engine startup-time bliss: Google Cloud Performance Atlas

+
0
1
0

 ·
Reply

[![photo.jpg](../_resources/e2be15e6c9918b97ed60be41bda087bc.jpg)](https://apis.google.com/u/0/wm/1/108859978805990147091)

### [Michael Feldman](https://apis.google.com/u/0/wm/1/108859978805990147091)

[3 weeks ago](https://apis.google.com/u/0/wm/1/108859978805990147091/posts/gd8t7ApmDrn)  -  Shared publicly

every millisecond counts. got it.
+
0
1
0

 ·
Reply

[![photo.jpg](../_resources/3b80afc5e59efcb26566a688b41ccc6a.jpg)](https://apis.google.com/u/0/wm/1/115895467080051313138)

### [Toddy Mladenov](https://apis.google.com/u/0/wm/1/115895467080051313138) via Google+

[3 weeks ago](https://apis.google.com/u/0/wm/1/+ToddyMladenovMe/posts/ADEPhzcZ5Fr)  -  Shared publicly

Google Compute Engine startup time

https://cloudplatform.googleblog.com/2017/07/three-steps-to-Compute-Engine-startup-time-bliss-Google-Cloud-Performance-Atlas.html

[#cloud](https://apis.google.com/s/%23cloud)  [#iaas](https://apis.google.com/s/%23iaas)  [#performance](https://apis.google.com/s/%23performance)

+
0
1
0

 ·
Reply

Labels:[Compute](https://cloudplatform.googleblog.com/search/label/Compute)